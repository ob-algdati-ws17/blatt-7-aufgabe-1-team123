<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>AVLTree-team123: AVLTree::Node Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AVLTree-team123
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="class_a_v_l_tree.html">AVLTree</a></li><li class="navelem"><a class="el" href="struct_a_v_l_tree_1_1_node.html">Node</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="struct_a_v_l_tree_1_1_node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AVLTree::Node Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3ba5d16b3e5d5f3e60e40c42eeb9fe8f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_l_tree_1_1_node.html#a3ba5d16b3e5d5f3e60e40c42eeb9fe8f">Node</a> (const int k, <a class="el" href="class_a_v_l_tree.html">AVLTree</a> *t)</td></tr>
<tr class="separator:a3ba5d16b3e5d5f3e60e40c42eeb9fe8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1117ae6ab3244805874793c1d5ee8b2f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_l_tree_1_1_node.html#a1117ae6ab3244805874793c1d5ee8b2f">Node</a> (const int k, <a class="el" href="struct_a_v_l_tree_1_1_node.html">Node</a> *p, <a class="el" href="struct_a_v_l_tree_1_1_node.html">Node</a> *l, <a class="el" href="struct_a_v_l_tree_1_1_node.html">Node</a> *r, <a class="el" href="class_a_v_l_tree.html">AVLTree</a> *t)</td></tr>
<tr class="separator:a1117ae6ab3244805874793c1d5ee8b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ad99beb74c565d897062ffc7e5c63e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_l_tree_1_1_node.html#aa8ad99beb74c565d897062ffc7e5c63e">~Node</a> ()</td></tr>
<tr class="separator:aa8ad99beb74c565d897062ffc7e5c63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2ab8a26dd9e1fbfbca82aa9f98f278"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_l_tree_1_1_node.html#a5b2ab8a26dd9e1fbfbca82aa9f98f278">upin</a> (bool growedLeft)</td></tr>
<tr class="separator:a5b2ab8a26dd9e1fbfbca82aa9f98f278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee0b8ffb6df00e4658c734f273b5f2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_l_tree_1_1_node.html#afee0b8ffb6df00e4658c734f273b5f2d">upout</a> ()</td></tr>
<tr class="separator:afee0b8ffb6df00e4658c734f273b5f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520e779ded833b31ba5c3483ce00aaba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_l_tree_1_1_node.html#a520e779ded833b31ba5c3483ce00aaba">leftRotation</a> ()</td></tr>
<tr class="separator:a520e779ded833b31ba5c3483ce00aaba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9db9c0dd0562ba0106b6e383ad534b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_l_tree_1_1_node.html#aae9db9c0dd0562ba0106b6e383ad534b">rightLeftRotation</a> ()</td></tr>
<tr class="separator:aae9db9c0dd0562ba0106b6e383ad534b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50fc27eeedac63ec35b007866c2446f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_l_tree_1_1_node.html#aa50fc27eeedac63ec35b007866c2446f">leftRightRotation</a> ()</td></tr>
<tr class="separator:aa50fc27eeedac63ec35b007866c2446f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38475368dc4b6779e6d60ee7727a93fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_l_tree_1_1_node.html#a38475368dc4b6779e6d60ee7727a93fd">rightRotation</a> ()</td></tr>
<tr class="separator:a38475368dc4b6779e6d60ee7727a93fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65cbc4a3d89d6713fc6da8fdbd39586e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_l_tree_1_1_node.html#a65cbc4a3d89d6713fc6da8fdbd39586e">isRoot</a> ()</td></tr>
<tr class="separator:a65cbc4a3d89d6713fc6da8fdbd39586e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26cc16f63d0746afc04033a13127ad5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_l_tree_1_1_node.html#ad26cc16f63d0746afc04033a13127ad5">isLeftFollower</a> ()</td></tr>
<tr class="separator:ad26cc16f63d0746afc04033a13127ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0d236d4d02c41799d7dedcf09fe910"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_l_tree_1_1_node.html#a7f0d236d4d02c41799d7dedcf09fe910">height</a> ()</td></tr>
<tr class="separator:a7f0d236d4d02c41799d7dedcf09fe910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682afb027a6d19f170b91eba87013c60"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_l_tree_1_1_node.html#a682afb027a6d19f170b91eba87013c60">preorder</a> () const </td></tr>
<tr class="separator:a682afb027a6d19f170b91eba87013c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bba83600c059cf329fd29e775e9043"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_l_tree_1_1_node.html#ad1bba83600c059cf329fd29e775e9043">inorder</a> () const </td></tr>
<tr class="separator:ad1bba83600c059cf329fd29e775e9043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02a8283c02926a3cad5564e03f01c96"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_l_tree_1_1_node.html#af02a8283c02926a3cad5564e03f01c96">postorder</a> () const </td></tr>
<tr class="separator:af02a8283c02926a3cad5564e03f01c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a4afbd1c00dd12942b965455335077c82"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_l_tree_1_1_node.html#a4afbd1c00dd12942b965455335077c82">key</a></td></tr>
<tr class="separator:a4afbd1c00dd12942b965455335077c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe949bde76e74faf4aaeab7266f3520"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_a_v_l_tree_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_l_tree_1_1_node.html#a6fe949bde76e74faf4aaeab7266f3520">previous</a> = nullptr</td></tr>
<tr class="separator:a6fe949bde76e74faf4aaeab7266f3520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a126656110bee7954c9e97b3aa2ae0f0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_a_v_l_tree_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_l_tree_1_1_node.html#a126656110bee7954c9e97b3aa2ae0f0f">left</a> = nullptr</td></tr>
<tr class="separator:a126656110bee7954c9e97b3aa2ae0f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cf9ab498b259eeec276f080e0bddd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_a_v_l_tree_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_l_tree_1_1_node.html#ad4cf9ab498b259eeec276f080e0bddd4">right</a> = nullptr</td></tr>
<tr class="separator:ad4cf9ab498b259eeec276f080e0bddd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e96dd90c70b3467e0c660b878f29e92"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_l_tree_1_1_node.html#a4e96dd90c70b3467e0c660b878f29e92">balance</a> = 0</td></tr>
<tr class="separator:a4e96dd90c70b3467e0c660b878f29e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57af528cf489986a8035de073cf44995"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_v_l_tree.html">AVLTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_l_tree_1_1_node.html#a57af528cf489986a8035de073cf44995">tree</a> = nullptr</td></tr>
<tr class="separator:a57af528cf489986a8035de073cf44995"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Nodes are the elements saved in the AVL Tree and the purpose of one node is to save exactly one integer value. Futher, every node knows his two sons called right and left node. If a node is a leaf, the sons are nullpointer. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a3ba5d16b3e5d5f3e60e40c42eeb9fe8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVLTree::Node::Node </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_v_l_tree.html">AVLTree</a> *&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new node with this value in the tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the key, the node contains. </td></tr>
    <tr><td class="paramname">t</td><td>the tree, where the node is placed in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1117ae6ab3244805874793c1d5ee8b2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVLTree::Node::Node </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_v_l_tree_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_v_l_tree_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_v_l_tree_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_v_l_tree.html">AVLTree</a> *&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new node with this value and this predefined position in the tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the key, the node contains. </td></tr>
    <tr><td class="paramname">p</td><td>the pointer on the previous node. </td></tr>
    <tr><td class="paramname">l</td><td>the pointer on the next smaller node. </td></tr>
    <tr><td class="paramname">r</td><td>the pointer on the next bigger node. </td></tr>
    <tr><td class="paramname">t</td><td>the tree, where the node is placed in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa8ad99beb74c565d897062ffc7e5c63e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVLTree::Node::~Node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delets the node; </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7f0d236d4d02c41799d7dedcf09fe910"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVLTree::Node::height </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the hight of a tree, defined by the maximum number of connections between the root and a leaf. </p><dl class="section return"><dt>Returns</dt><dd>hight of the tree. </dd></dl>

</div>
</div>
<a class="anchor" id="ad1bba83600c059cf329fd29e775e9043"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; * AVLTree::Node::inorder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The inorder goes from the left branch of the tree (in preorder) to the root to the right branch of the tree (in preorder). </p><dl class="section return"><dt>Returns</dt><dd>a inordered vector. </dd></dl>

</div>
</div>
<a class="anchor" id="ad26cc16f63d0746afc04033a13127ad5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AVLTree::Node::isLeftFollower </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this node is the left follower of its previous element, else false. </p><dl class="section return"><dt>Returns</dt><dd>true if this node is the left follower of its previous element, else false. </dd></dl>

</div>
</div>
<a class="anchor" id="a65cbc4a3d89d6713fc6da8fdbd39586e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AVLTree::Node::isRoot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns if the current node is the root of the tree or not. </p><dl class="section return"><dt>Returns</dt><dd>true, if the node is the root of the tree. </dd></dl>

</div>
</div>
<a class="anchor" id="aa50fc27eeedac63ec35b007866c2446f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AVLTree::Node::leftRightRotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rotates the (sub)tree first to the left and then to the right, so that the left follower of this node gets the root of the (sub)tree. The rotation includes just nodes in the subtree of which the previous of this node is the root. </p>

</div>
</div>
<a class="anchor" id="a520e779ded833b31ba5c3483ce00aaba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AVLTree::Node::leftRotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rotates the (sub)tree to the left so that this node will get the root of the (sub)tree. The rotation includes just nodes in the subtree of which the previous of this node is the root. </p>

</div>
</div>
<a class="anchor" id="af02a8283c02926a3cad5564e03f01c96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; * AVLTree::Node::postorder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The postorder goes from the left branch of the tree (in preorder) to the right branch of the tree (in preorder) to the root. </p><dl class="section return"><dt>Returns</dt><dd>a postordered vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a682afb027a6d19f170b91eba87013c60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; * AVLTree::Node::preorder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The preorder goes from the root to the left branch of the tree (in preorder) to the right branch of the tree (in preorder). </p><dl class="section return"><dt>Returns</dt><dd>a preordered vector. </dd></dl>

</div>
</div>
<a class="anchor" id="aae9db9c0dd0562ba0106b6e383ad534b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AVLTree::Node::rightLeftRotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rotates the (sub)tree first to the right and then to the left, so that the right follower of this node gets the root of the (sub)tree. The rotation includes just nodes in the subtree of which the previous of this node is the root. </p>

</div>
</div>
<a class="anchor" id="a38475368dc4b6779e6d60ee7727a93fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AVLTree::Node::rightRotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rotates the (sub)tree to the right so that this node will get the root of the (sub)tree. The rotation includes just nodes in the subtree of which the previous of this node is the root. </p>

</div>
</div>
<a class="anchor" id="a5b2ab8a26dd9e1fbfbca82aa9f98f278"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AVLTree::Node::upin </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>growedLeft</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ensures that the tree is still an AVL-Tree when a node is inserted. If the tree is not an AVL-Tree the necessary rotation will be executed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">growedLeft</td><td>true if the left subtree of the noed growed, false if the right subtree of the node growed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afee0b8ffb6df00e4658c734f273b5f2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AVLTree::Node::upout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ensures that the tree is still an AVL-Tree when a node is removed. If the tree is not an AVL-Tree the necessary rotation will be executed. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a4e96dd90c70b3467e0c660b878f29e92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVLTree::Node::balance = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a balace factor. Here just the following values are alloed: -1: there is one more node in the left branch than in the right branch of the current node. 0: there are as many nodes in the left branch as in the right branch. This node is perfectly balanced. 1: there is one more node in the right branch than in the left branch of the current node. If there is another value in any of the nodes in the tree, the tree has to be rearranged. </p>

</div>
</div>
<a class="anchor" id="a4afbd1c00dd12942b965455335077c82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int AVLTree::Node::key</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The key value this node contains. By this value difines the position of the node in the tree. The value is constant, so it can never be changed. </p>

</div>
</div>
<a class="anchor" id="a126656110bee7954c9e97b3aa2ae0f0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_v_l_tree_1_1_node.html">Node</a>* AVLTree::Node::left = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a pointer on the next element in the tree, that has a smaller value, than the current <a class="el" href="struct_a_v_l_tree_1_1_node.html">Node</a>. </p>

</div>
</div>
<a class="anchor" id="a6fe949bde76e74faf4aaeab7266f3520"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_v_l_tree_1_1_node.html">Node</a>* AVLTree::Node::previous = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a pointer on the previous node in the tree. </p>

</div>
</div>
<a class="anchor" id="ad4cf9ab498b259eeec276f080e0bddd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_v_l_tree_1_1_node.html">Node</a>* AVLTree::Node::right = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a pointer on the next element in the tree, that has a greater value, than the current <a class="el" href="struct_a_v_l_tree_1_1_node.html">Node</a>. </p>

</div>
</div>
<a class="anchor" id="a57af528cf489986a8035de073cf44995"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_v_l_tree.html">AVLTree</a>* AVLTree::Node::tree = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The tree, where the node belongs to. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>avltree/<a class="el" href="_a_v_l_tree_8h_source.html">AVLTree.h</a></li>
<li>avltree/<a class="el" href="_a_v_l_tree_8cpp.html">AVLTree.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
